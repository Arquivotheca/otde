/* ANSI-C code produced by gperf version 2.7 */
/* Command-line: gperf -L ANSI-C -C -c -o -t -k * -NfindTag -D -s 2 khtmltags.gperf  */
/* This file is automatically generated from khtmltags.in by maketags, do not edit */
/* Copyright 1998 W. Bastian */
#include "tags.h"
struct tags {
    char *name;
    int id;
};

#define TOTAL_KEYWORDS 87
#define MIN_WORD_LENGTH 1
#define MAX_WORD_LENGTH 10
#define MIN_HASH_VALUE 1
#define MAX_HASH_VALUE 300
/* maximum key range = 300, duplicates = 1 */

#ifdef __GNUC__
__inline
#endif
static unsigned int
hash (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301,  25,
       45,  75,  80,  90,  15, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301,   0,  60,  90,
       20,   0,  70,   0,  10,  15,   0,  60,  30,  95,
       10,   0, 120,  10,   5,   5,   0,  40,   0, 301,
        5,   5, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301, 301, 301, 301, 301,
      301, 301, 301, 301, 301, 301
    };
  register int hval = len;

  switch (hval)
    {
      default:
      case 10:
        hval += asso_values[(unsigned char)str[9]];
      case 9:
        hval += asso_values[(unsigned char)str[8]];
      case 8:
        hval += asso_values[(unsigned char)str[7]];
      case 7:
        hval += asso_values[(unsigned char)str[6]];
      case 6:
        hval += asso_values[(unsigned char)str[5]];
      case 5:
        hval += asso_values[(unsigned char)str[4]];
      case 4:
        hval += asso_values[(unsigned char)str[3]];
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      case 2:
        hval += asso_values[(unsigned char)str[1]];
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

#ifdef __GNUC__
__inline
#endif
const struct tags *
findTag (register const char *str, register unsigned int len)
{
  static const struct tags wordlist[] =
    {
      {"a", ID_A},
      {"tt", ID_TT},
      {"s", ID_S},
      {"tr", ID_TR},
      {"var", ID_VAR},
      {"area", ID_AREA},
      {"q", ID_Q},
      {"th", ID_TH},
      {"i", ID_I},
      {"hr", ID_HR},
      {"textarea", ID_TEXTAREA},
      {"dt", ID_DT},
      {"td", ID_TD},
      {"strong", ID_STRONG},
      {"h6", ID_H6},
      {"ol", ID_OL},
      {"ins", ID_INS},
      {"h1", ID_H1},
      {"div", ID_DIV},
      {"u", ID_U},
      {"dd", ID_DD},
      {"dir", ID_DIR},
      {"style", ID_STYLE},
      {"li", ID_LI},
      {"title", ID_TITLE},
      {"dl", ID_DL},
      {"del", ID_DEL},
      {"h2", ID_H2},
      {"b", ID_B},
      {"address", ID_ADDRESS},
      {"legend", ID_LEGEND},
      {"br", ID_BR},
      {"base", ID_BASE},
      {"ul", ID_UL},
      {"isindex", ID_ISINDEX},
      {"big", ID_BIG},
      {"nobr", ID_NOBR},
      {"listing", ID_LISTING},
      {"bdo", ID_BDO},
      {"font", ID_FONT},
      {"h3", ID_H3},
      {"body", ID_BODY},
      {"strike", ID_STRIKE},
      {"h4", ID_H4},
      {"table", ID_TABLE},
      {"em", ID_EM},
      {"meta", ID_META},
      {"h5", ID_H5},
      {"dfn", ID_DFN},
      {"sub", ID_SUB},
      {"cite", ID_CITE},
      {"center", ID_CENTER},
      {"img", ID_IMG},
      {"code", ID_CODE},
      {"button", ID_BUTTON},
      {"link", ID_LINK},
      {"p", ID_P},
      {"label", ID_LABEL},
      {"pre", ID_PRE},
      {"abbr", ID_ABBR},
      {"select", ID_SELECT},
      {"span", ID_SPAN},
      {"kbd", ID_KBD},
      {"fieldset", ID_FIELDSET},
      {"menu", ID_MENU},
      {"option", ID_OPTION},
      {"basefont", ID_BASEFONT},
      {"cell", ID_CELL},
      {"object", ID_OBJECT},
      {"small", ID_SMALL},
      {"sup", ID_SUP},
      {"form", ID_FORM},
      {"frame", ID_FRAME},
      {"frameset", ID_FRAMESET},
      {"input", ID_INPUT},
      {"iframe", ID_IFRAME},
      {"noframes", ID_NOFRAMES},
      {"acronym", ID_ACRONYM},
      {"map", ID_MAP},
      {"samp", ID_SAMP},
      {"param", ID_PARAM},
      {"script", ID_SCRIPT},
      {"caption", ID_CAPTION},
      {"noscript", ID_NOSCRIPT},
      {"applet", ID_APPLET},
      {"optgroup", ID_OPTGROUP},
      {"blockquote", ID_BLOCKQUOTE}
    };

  static const signed char lookup[] =
    {
        -1,    0,    1,   -1,   -1,   -1,    2,    3,
         4,    5,   -1,    6,    7,   -1,   -1,   -1,
         8,    9,   10,   -1,   -1,   -1, -111,  -76,
        -2,   -1,   13,   14,   -1,   -1,   -1,   -1,
        15,   16,   -1,   -1,   -1,   17,   18,   -1,
        -1,   19,   20,   21,   -1,   22,   -1,   23,
        -1,   -1,   24,   -1,   25,   26,   -1,   -1,
        -1,   27,   -1,   -1,   -1,   28,   29,   -1,
        -1,   -1,   30,   31,   -1,   32,   -1,   -1,
        33,   -1,   -1,   -1,   -1,   34,   35,   36,
        -1,   -1,   37,   38,   39,   -1,   -1,   40,
        -1,   41,   -1,   42,   43,   -1,   -1,   44,
        -1,   45,   -1,   46,   -1,   -1,   47,   48,
        -1,   -1,   -1,   -1,   49,   50,   -1,   51,
        -1,   52,   53,   -1,   54,   -1,   -1,   55,
        -1,   56,   -1,   -1,   -1,   57,   -1,   -1,
        58,   59,   -1,   60,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   61,   -1,   -1,   -1,   62,
        -1,   -1,   -1,   -1,   63,   64,   -1,   65,
        -1,   66,   67,   -1,   68,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   69,   -1,   -1,
        70,   -1,   -1,   -1,   -1,   -1,   71,   72,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   73,
        -1,   -1,   -1,   -1,   -1,   -1,   74,   75,
        -1,   76,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   77,   -1,   -1,   -1,
        -1,   -1,   78,   -1,   -1,   -1,   -1,   -1,
        79,   80,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   81,   82,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   83,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   84,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        -1,   -1,   -1,   -1,   -1,   85,   -1,   -1,
        -1,   -1,   -1,   -1,   86
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register int index = lookup[key];

          if (index >= 0)
            {
              register const char *s = wordlist[index].name;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[index];
            }
          else if (index < -TOTAL_KEYWORDS)
            {
              register int offset = - 1 - TOTAL_KEYWORDS - index;
              register const struct tags *wordptr = &wordlist[TOTAL_KEYWORDS + lookup[offset]];
              register const struct tags *wordendptr = wordptr + -lookup[offset + 1];

              while (wordptr < wordendptr)
                {
                  register const char *s = wordptr->name;

                  if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                    return wordptr;
                  wordptr++;
                }
            }
        }
    }
  return 0;
}
