/* ANSI-C code produced by gperf version 2.7 */
/* Command-line: gperf -L ANSI-C -C -G -c -o -t -k * -NfindTag -D -s 2 khtmltags.gperf  */
/* This file is automatically generated from khtmltags.in by maketags, do not edit */
/* Copyright 1998 W. Bastian */
#include "khtmltags.h"
struct tags {
    char *name;
    int id;
};

#define TOTAL_KEYWORDS 93
#define MIN_WORD_LENGTH 1
#define MAX_WORD_LENGTH 10
#define MIN_HASH_VALUE 1
#define MAX_HASH_VALUE 353
/* maximum key range = 353, duplicates = 1 */

#ifdef __GNUC__
__inline
#endif
static unsigned int
hash (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354,  10,
       15,  35,  40,  45,  50, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354,   0,  95, 115,
       35,   0,  70,  20,  15,  30,   0,  20,  10,  85,
        5,   0, 110,  10,   5,   5,   0,  85,   0, 354,
        5,   0, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
      354, 354, 354, 354, 354, 354
    };
  register int hval = len;

  switch (hval)
    {
      default:
      case 10:
        hval += asso_values[(unsigned char)str[9]];
      case 9:
        hval += asso_values[(unsigned char)str[8]];
      case 8:
        hval += asso_values[(unsigned char)str[7]];
      case 7:
        hval += asso_values[(unsigned char)str[6]];
      case 6:
        hval += asso_values[(unsigned char)str[5]];
      case 5:
        hval += asso_values[(unsigned char)str[4]];
      case 4:
        hval += asso_values[(unsigned char)str[3]];
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      case 2:
        hval += asso_values[(unsigned char)str[1]];
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

static const struct tags wordlist[] =
  {
    {"a", ID_A},
    {"tt", ID_TT},
    {"s", ID_S},
    {"tr", ID_TR},
    {"var", ID_VAR},
    {"area", ID_AREA},
    {"q", ID_Q},
    {"ol", ID_OL},
    {"th", ID_TH},
    {"textarea", ID_TEXTAREA},
    {"style", ID_STYLE},
    {"hr", ID_HR},
    {"h1", ID_H1},
    {"i", ID_I},
    {"h2", ID_H2},
    {"dt", ID_DT},
    {"td", ID_TD},
    {"strong", ID_STRONG},
    {"li", ID_LI},
    {"ins", ID_INS},
    {"title", ID_TITLE},
    {"dl", ID_DL},
    {"del", ID_DEL},
    {"h3", ID_H3},
    {"head", ID_HEAD},
    {"thead", ID_THEAD},
    {"h4", ID_H4},
    {"h5", ID_H5},
    {"strike", ID_STRIKE},
    {"h6", ID_H6},
    {"div", ID_DIV},
    {"link", ID_LINK},
    {"dd", ID_DD},
    {"dir", ID_DIR},
    {"tfoot", ID_TFOOT},
    {"legend", ID_LEGEND},
    {"font", ID_FONT},
    {"u", ID_U},
    {"em", ID_EM},
    {"meta", ID_META},
    {"address", ID_ADDRESS},
    {"b", ID_B},
    {"ul", ID_UL},
    {"br", ID_BR},
    {"base", ID_BASE},
    {"listing", ID_LISTING},
    {"nobr", ID_NOBR},
    {"table", ID_TABLE},
    {"p", ID_P},
    {"dfn", ID_DFN},
    {"small", ID_SMALL},
    {"isindex", ID_ISINDEX},
    {"pre", ID_PRE},
    {"label", ID_LABEL},
    {"span", ID_SPAN},
    {"col", ID_COL},
    {"center", ID_CENTER},
    {"bdo", ID_BDO},
    {"body", ID_BODY},
    {"tbody", ID_TBODY},
    {"select", ID_SELECT},
    {"img", ID_IMG},
    {"cell", ID_CELL},
    {"big", ID_BIG},
    {"cite", ID_CITE},
    {"option", ID_OPTION},
    {"kbd", ID_KBD},
    {"code", ID_CODE},
    {"fieldset", ID_FIELDSET},
    {"form", ID_FORM},
    {"frame", ID_FRAME},
    {"frameset", ID_FRAMESET},
    {"noframes", ID_NOFRAMES},
    {"menu", ID_MENU},
    {"basefont", ID_BASEFONT},
    {"sub", ID_SUB},
    {"button", ID_BUTTON},
    {"iframe", ID_IFRAME},
    {"map", ID_MAP},
    {"abbr", ID_ABBR},
    {"sup", ID_SUP},
    {"samp", ID_SAMP},
    {"param", ID_PARAM},
    {"object", ID_OBJECT},
    {"acronym", ID_ACRONYM},
    {"input", ID_INPUT},
    {"applet", ID_APPLET},
    {"caption", ID_CAPTION},
    {"script", ID_SCRIPT},
    {"noscript", ID_NOSCRIPT},
    {"optgroup", ID_OPTGROUP},
    {"blockquote", ID_BLOCKQUOTE},
    {"colgroup", ID_COLGROUP}
  };

static const short lookup[] =
  {
      -1,    0,    1,   -1,   -1,   -1,    2,    3,
       4,    5,   -1,    6,    7,   -1,   -1,   -1,
      -1,    8,    9,   -1,   10,   -1,   11,   -1,
      -1,   -1,   -1,   12,   -1,   -1,   -1,   13,
      14,   -1,   -1,   -1,   -1, -132,  -78,   -2,
      -1,   17,   18,   19,   -1,   20,   -1,   21,
      22,   -1,   -1,   -1,   23,   -1,   24,   25,
      -1,   26,   -1,   -1,   -1,   -1,   27,   -1,
      -1,   -1,   28,   29,   30,   31,   -1,   -1,
      32,   33,   -1,   34,   35,   -1,   -1,   36,
      -1,   -1,   -1,   -1,   -1,   -1,   37,   38,
      -1,   39,   -1,   -1,   40,   -1,   -1,   -1,
      41,   42,   -1,   -1,   -1,   -1,   43,   -1,
      44,   -1,   -1,   45,   -1,   46,   47,   48,
      -1,   49,   -1,   50,   -1,   51,   52,   -1,
      53,   -1,   -1,   -1,   54,   -1,   -1,   -1,
      55,   -1,   -1,   56,   -1,   57,   58,   59,
      60,   -1,   61,   62,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   63,   64,   -1,   65,
      -1,   66,   67,   -1,   -1,   -1,   68,   -1,
      -1,   -1,   -1,   -1,   69,   70,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   71,   -1,   -1,
      -1,   -1,   72,   73,   -1,   -1,   -1,   74,
      -1,   -1,   -1,   -1,   75,   -1,   -1,   76,
      -1,   -1,   -1,   -1,   77,   -1,   78,   79,
      -1,   -1,   -1,   80,   81,   82,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      83,   84,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   85,   86,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   87,   -1,   -1,   -1,   88,
      -1,   -1,   -1,   -1,   -1,   -1,   89,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   -1,   90,   -1,   -1,   -1,   -1,   -1,
      -1,   91,   -1,   -1,   -1,   -1,   -1,   -1,
      -1,   92
  };

#ifdef __GNUC__
__inline
#endif
const struct tags *
findTag (register const char *str, register unsigned int len)
{
  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register int index = lookup[key];

          if (index >= 0)
            {
              register const char *s = wordlist[index].name;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[index];
            }
          else if (index < -TOTAL_KEYWORDS)
            {
              register int offset = - 1 - TOTAL_KEYWORDS - index;
              register const struct tags *wordptr = &wordlist[TOTAL_KEYWORDS + lookup[offset]];
              register const struct tags *wordendptr = wordptr + -lookup[offset + 1];

              while (wordptr < wordendptr)
                {
                  register const char *s = wordptr->name;

                  if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                    return wordptr;
                  wordptr++;
                }
            }
        }
    }
  return 0;
}
