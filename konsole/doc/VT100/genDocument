RES=techref.html

function header
{
cat << etx >> $RES
<h2>
<table width=100%>
<tr><td align=center bgcolor=#d0d0d0></td></tr>
<tr><td align=center bgcolor=#d0d0d0>$1</td></tr>
<tr><td align=center bgcolor=#d0d0d0></td></tr>
</table>
</h2>
etx
}

cat > $RES /dev/null

# -- HTML Header --------------------------------------------------------------------

cat >> $RES << etx
<html>
<head>
<title>VT100</title>
<!-- NOTE: this page is generated using the "genDocument" script -->
</head>
<body bgcolor=white>

<hr>

etx

# -- Editors Notes ------------------------------------------------------------------

cat >> $RES << etx

<h1><center>VT100</center></h1>
<center><img src="vt100.gif"></center>

<it>Please note that this text is under construction</it>

<h2>Preface</h2>

This document accompanies the Konsole and Kom programs, which are mainly terminal
emulations.  Since material about the extend and precise semantics of the emulatation
intended by these programs is hard to find on the internet today, it came out
nessesary to include a more precise specification within their release.
<p>
Hopefully, this helps to clearify the relation to the VT100, VT102, Linux, XTerm
and ansi.sys (ANSI-BBS) terminals, which are the target of these programs. Further,
it specifies which codes are interpreted by them, and what has been omitted.
<p>
To begin with, all of the above call themselfes "ANSI" emulations, which makes this
notion pretty vage. "ANSI" referes here to the American National Standards 
Institute's documents X3.41-1974 and X3.64-1977. DEC partially implemented this
standart in their VT100 terminal, with some additions. The VT102 is a later extention
of that. Both the Linux console and the XTerm emulation implement most of VT102,
with some additions. MS stepped in later and produced another ANSI emulation,
<code>ansi.sys</code>, for their OS, which became of some relevance in BBS style
telecommunication programs. One can view this as a small subset of the VT100 
emulation, with some additions, of cause.
<p>
This situation is further confused by the fact, that often many versions of the
above terminals and emulations are out, one able to do a little more or less then
the other. Especially the later makes the production of an emulation a difficult
task.
<p>
This document contains the material collected and
attempts to describe not only the abilities of konsole, but also to give a
full reference of the emulations that konsole is capable of, but does
eventually not implement completely.
<p>
Currently, the body of this document is mainly a concept data base, that
referes to the VT100 component of the emulation. Any indication whether
these codes are implemented by konsole or not are missing. So do additional
codes origination from the Xterm and Linux console emulation. If you need to
know the precise extend of the emulation, please refere to the TEmuVt102.C
source, which contains a table, that fully answers the question. I'm in the
process to integrate this table into this concept data base, to link the
konsole emulation sources closely with it's documentation.


<h2>Notes &amp; todos</h2>
<ul>
<li>Include complete reference on keyboard material.
<li>Check for explaination of out-of-bound values.
<li>Include VT52, VT102, XTERM, LINUX-console codes
<li>Make the whole document more concept oriented
<li>See the section <em>Method of description</em>, below
<li>Derive some summarizing lists.
</ul>
etx

# -- Codes --------------------------------------------------------------------------

header "Terminal Control Commands"

cat >> $RES << etx

The VT100 is an upward and downward software-compatible terminal;
that is, previous Digital video terminals have Digital's private standards
for control sequences. The American National Standards Institute has since
standardized escape and control sequences in terminals in documents X3.41-1974
and X3.64-1977.
<p>
The VT100 is compatible with both the previous Digital standard and
ANSI standards.  Customers may use existing Digital software designed around
the VT52 or new VT100 software.  The VT100 has a "VT52 compatible" mode in
which the VT100 responds to control sequences like a VT52.  In this mode, most
of the new VT100 features cannot be used.
<p>
Throughout this document references will be made to "VT52 mode" or
"ANSI mode".  These two terms are used to indicate the VT100's software
compatibility.
<p>
<em>NOTE</em>: The ANSI standards allow the manufacturer flexibility in implementing
each function.  This document describes how the VT100 will respond to the
implemented ANSI central function.
<p>

<!-- BEGIN: new section about the codes -->

<h2>Method of description</h2>

<em>All the following in this section is an outline</em>. <p>

Parts of the terminal description
<ul>
<li>State
<br>This is mainly the screen, the cursor (including it's graphical state)
    and some hidden mode variables. Note that the state cannot be investigated
    by the attached host.
<li>Interface
<br>That's what goes over the wire. Beside being related to objects, this
    appears so closely related to contemporal process communication, that
    it might be discussed in likely terms.
<br>We have information flowing in both directions. On could destinguist
    between:
<li>Commands
<br>These are "calls" of the terminals interface by the host which cause
    some change of the terminals state, but do not end in a response.
<li>Requests
<br>These are "calls" of the terminals interface by the host which do not cause
    any change of the terminals state, but end in a response of the terminal.
    Clearly, requests are somehow used to investigate the state of the terminal.
<li>Events
<br>These are signals from the terminal caused by the user affecting the
    mouse or keyboard to the host.
<li>Replys
<br>These are send by the terminal as a result of a Request from the hosts.
<li>Encoding/Decoding
</ul>


<!-- END -->
etx

header "Control Sequences"
cat >> $RES << etx

Conceptually, the commands to the terminal emulation are encoded if form
of byte sequences to meet the restrictions of the transport media. These
sequences have pretty different originations and therefore the format of
the sequences are inhomogenous.
<p>
Refering both to their origin and form, one can group the overall encoding
schemes as follows:
<p>
<table>
<tr><td width=20% bgcolor=#d0d0d0>Name</td><td width=20% bgcolor=#d0d0d0>Pattern</td><td bgcolor=#d0d0d0>Scope</td><td bgcolor=#d0d0d0>Comment</td></tr>
<tr><td>Printable Ascii Characters</td><td>32..126</td><td>ASCII ECMA</td>
  <td>This is the most original pattern of all. The characters to be
      displayed are passed over the chanel and are interpreted by the
      terminal (emulation) as instructions to display the corresponding
      glyph of the ascii character set. Contempory emulations include the
      upper half (128..255) of the extentions to the national ascii character
      sets, also.</td></tr>
<tr><td>Ascii Control Characters</td><td>0..26,28..31,127</td><td>ASCII ECMA</td>
  <td>Ascii defines some non-printable, but format effecting characters, too.
      Depending on the emulation, at least some of them are given a meaning.
      The typically implemented ones are those that are handled by a teletype
      like device.</td></tr>
<tr><td>Simple Escape Sequence</td><td><b>ESC</b> <i>C</i></td><td>ECMA</td>
  <td>These sequences are made up from an <b>ESC</b> character followed by
      exactly one other character in the range ???..???.</td></tr>
<tr><td>CSI Sequence</td>
  <td><b>ESC</b> <b>[</b> <i>Parameters</i> {<i>I</i>} <i>C</i></td>
  <td>ECMA</td>
  <td></td></tr>
<tr><td colspan=4>
  <p>
    The remaining codes are nonstandard but traditionalized hacks.
  <p>
    </td></tr>
<tr><td>DEC hacks</td>
 <td><b>ESC</b> <i>C</i> <i>D</i></td>
 <td>VT100</td>
 <td></td></tr>
<tr><td>XTERM hacks</td>
<td><b>ESC ]</b> <i>Pn</i> <b>;</b> <i>text</i> <b>BEL</b></td>
<td>XTERM</td>
<td></td>
<tr><td colspan=4>
  <p>
    VT52 uses a different (incompatible) set of escape codes. VT100 includes
    the VT52 emulation as a mode.
  <p>
    </td></tr>
</tr>
<tr><td>Simple Escape Sequence</td><td><b>ESC</b> <i>C</i></td><td>VT52</td>
  <td></td></tr>
<tr><td>Complex Escape Sequence</td><td><b>ESC</b> <b>Y</b> <i>X</i> <i>Y</i></td><td>VT52</td>
  <td></td></tr>

</table>

<h3>More on Control Sequences</h3>

<h4>Control Characters</h4>

Control characters (codes 0x00 - 0x1f inclusive) are specifically excluded
from the control sequence syntax, but may be embedded within a control
sequence.  Embedded control characters are executed as soon as they are
encountered by the VT100.  The processing of the control sequence then
continues with the next character recieved.  The exceptions are:
if the <a href=#ESC>ESC</a> character occurs, the current control sequence
is aborted, and a new one commences beginning with the <a href=#ESC>ESC</a>
just recieved.  If the character <a href=#CAN>CAN</a> (0x0c) or the
character <a href=#SUB>SUB</a> (0x0e) occurs,
the current control sequence is aborted.  The ability to embed control
characters allows the synchronization characters XON and XOFF to be
interpreted properly without affecting the control sequence.
<p>
<b>FIXME</b>: <i>I've to check this w.r.t. the "I" component in modern
   (EMCA) CSI sequences. Evtl. this is not compatible anymore.</i>
<p>

<h4>CSI Sequences</h4>

<dl>
<dt>Control Sequence Introducer (CSI):
<dd>An escape sequence that provides
    supplementary controls and is itself a prefix affecting the
    interpretation of a limited number of contiguous characters.
    In the VT100, the CSI is: &lt;ESC&gt;[

<dt>Parameter:
<dd>1. A string of zero or more decimal characters which
       represent a single value.  Leading zeros are ignored.  The
       decimal characters have a range of 0 (060) to 9 (071).
<br>2. The value so represented.

<dt>Numeric Parameter:
<dd>A parameter that represents a number, designated by Pn.

<dt>Selective Parameter:
<dd>A parameter that selects a subfunction from a
    specified set of subfunctions, designated by Ps.  In general, a
    control sequence with more than one selective parameter causes
    the same effect as several control sequences, each with one
    selective parameter, e.g., CSI Psa; Psb; Psc F is identical to
    CSI Psa F CSI Psb F CSI Psc F.

<dt>Parameter String:
<dd>A string of parameters separated by a semicolon.

<dt>Default:
<dd> A function-dependent value that is assumed when no explicit
     value, or a value of 0, is specified.

<dt>Final character:
<dd>A character whose bit combination terminates an escape or control sequence.
</dl>


<em>EXAMPLE</em>:  Control sequence to turn off all character attributes, then
turn on underscore and blink attributes (<a href=#SGR>SGR</a>).

<pre>                      Delimiters
                          / \       
                         /   \       
                         |   |
                        \ / \ /
Sequence:       &lt;ESC&gt;[ 0 ; 4 ; 5 m
                ^^^^^^ ^   ^   ^ ^
                |||||| |   |   | |
                \||||/  \  |  /  +------Final character
                 \||/    \ | /
                 CSI   Selective
                       Parameters
</pre>
The octal representation of this string is:
<pre>
   033 0133 060 073 064 073 065 0155
  &lt;ESC&gt;   [   0   ;   4   ;   5    m
</pre>


Alternate sequences which will accomplish the same thing:

<ul>
<li><code>&lt;ESC&gt;[;4;m     </code>
<li><code>&lt;ESC&gt;[m        </code>
<br><code>&lt;ESC&gt;[4m       </code>
<br><code>&lt;ESC&gt;[5m       </code>
<li><code>&lt;ESC&gt;[0;04;005m</code>
</ul>

<h4>DEC hacks</h4>

These form two groups of commands.
<p>
In one first the first character is a hash (<em>#</em>) and the following a digit.
This command group is used to denote VT100 specific instructions and can
safely be sonsidered to be obsolete. See
  <a href=#DECALN>DECALN</a>,
  <a href=#DECDHLB>DECDHLB</a>,
  <a href=#DECDHLT>DECDHLT</a>,
  <a href=#DECDWL>DECDWL</a> and
  <a href=#DECSWL>DECSWL</a>.
<p>
The second one is used to specify character set mappings (see <a
href=#SCS>SCS</a>). A CSI instruction to do this is specified in ECMA,
and this should be used as a replacement.

<h4>XTERM hacks</h4>

etx

header "The Concept Data Base"
cat >> $RES << etx

<i>The following text is a collection of several sorts of definitions and
   explainations. It is incomplete in many respects and a working draft.
   The author is well aware of the fact that this part of the document
   is of few use without having proper indexes.
</i>
   
<p>
All of the following control sequences are transmitted from the Host to
VT100 unless otherwise noted.  All of the control sequences are a subset of
those defined in ANSI X 3.64 1977 and ANSI X 3.41 1974.
<p>
The following text conforms to these formatting conventions:
<ul>
<li>Individual character literals are set in bold face. Ascii representation
    is used throughout, so <b>ESC</b> means the binary value of 27 and
    <b>[</b> a value of 91.

<li>Parameters are indicated by italic type faces.
<li>Parameter types usually are indicated as one of:
    <table>
    <tr><td><i>Pn </i></td><td>A string of digits representing a numerical value.</td></tr>
    <tr><td><i>Ps </i></td><td>A character that selects an item from a list.</td></tr>
    <tr><td><i>a-z</i></td><td>Any lowercase sequence of one or more
                        characters represent a value to be
                        entered (as in <i>Pn</i>), and the name in the
                        will be referred to in explanatory text.</td></tr>
    </table>

<li>Spaces are used only to improve readability, they do not occure in the
    control sequences unless otherwise indicated.

</ul>

<p>
The following attributes below have the following meaning:
<ul>
<li>VT100 - This code is known to VT100.
<li>ANSI  - This code is defined by ANSI.
<li>DEC   - This code is DEC private.
<li>Command - Sent from host to the terminal. <b>FIXME:</b>add Inquiery.
<li>Reply - Sent from terminal to the host (as response to an Inquiery).
<li>Event - Sent from terminal to the host (caused by a user activity).
<li>Mode - The entry is a mode.
</ul>
etx


./genTC.pl >> $RES

header "Modes"

cat >> $RES << etx
<a name=#MODES></a>


The Following is a list of VT100 modes which may be changed with Set
Mode (SM) and Reset Mode (RM) controls.

<h3>ANSI Specified Modes</h3>

<table border=1>
<tr><td>Parameter</td><td>Mnemonic</td><td>Function</td></tr>
<tr><td><hr></td><td><hr></td><td><hr></td></tr>
<tr><td>0        </td><td>        </td><td>Error (Ignored)</td></tr>
<tr><td>20       </td><td>LNM     </td><td>Line Feed/New Line Mode</td></tr>
</table>


<h3>DEC Private Modes</h3>

If the first character in the parameter string is ? (077), the
parameters are interpreted as DEC private parameters according to the
following:

<table border=1>
<tr><td>Parameter</td><td>Mnemonic</td><td>Function
<tr><td><hr></td><td><hr></td><td><hr></td></tr>
<tr><td>0</td><td>       </td><td>Error (Ignored)</td></tr>
<tr><td>1</td><td><a href=#DECCKM >DECCKM </a></td><td>Cursor Key     </td></tr>
<tr><td>2</td><td><a href=#DECANM >DECANM </a></td><td>ANSI/VT52      </td></tr>
<tr><td>3</td><td><a href=#DECCOLM>DECCOLM</a></td><td>Column         </td></tr>
<tr><td>4</td><td><a href=#DECSCLM>DECSCLM</a></td><td>Scrolling      </td></tr>
<tr><td>5</td><td><a href=#DECSCNM>DECSCNM</a></td><td>Screen         </td></tr>
<tr><td>6</td><td><a href=#DECOM  >DECOM  </a></td><td>Origin         </td></tr>
<tr><td>7</td><td><a href=#DECAWM >DECAWM </a></td><td>Auto Wrap      </td></tr>
<tr><td>8</td><td><a href=#DECARM>DECARM </a></td><td>Auto Repeat    </td></tr>
<tr><td>9</td><td><a href=#DECINLM>DECINLM</a></td><td>Interlace      </td></tr>
</table>

Any other parameter values are ignored.

<p>
The following modes, which are specified in the ANSI standard, may be
considered to be permanently set, permanently reset, or not applicable,
as noted.

<table border=1>
<tr><td>Mnemonic</td><td>Function                 </td><td>State</td></tr>

<tr><td>CRM     </td><td>Control Representation   </td><td>Reset</td></tr>
<tr><td>EBM     </td><td>Editing Boundary         </td><td>Reset</td></tr>
<tr><td>ERM     </td><td>Erasure                  </td><td>Set  </td></tr>
<tr><td>FEAM    </td><td>Format Effector Action   </td><td>Reset</td></tr>
<tr><td>FETM    </td><td>Format Effector Transfer </td><td>Reset</td></tr>
<tr><td>GATM    </td><td>Guarded Area Transfer    </td><td>NA   </td></tr>
<tr><td>HEM     </td><td>Horizontal Editing       </td><td>NA   </td></tr>
<tr><td>IRM     </td><td>Insertion-replacement    </td><td>Reset</td></tr>
<tr><td>KAM     </td><td>Keyboard Action          </td><td>Reset</td></tr>
<tr><td>MATM    </td><td>Multiple area transfer   </td><td>NA   </td></tr>
<tr><td>PUM     </td><td>Positioning Unit         </td><td>Reset</td></tr>
<tr><td>SATM    </td><td>Selected Area Transfer   </td><td>NA   </td></tr>
<tr><td>SRTM    </td><td>Status Reporting Transfer</td><td>Reset</td></tr>
<tr><td>TSM     </td><td>Tabulation Stop          </td><td>Reset</td></tr>
<tr><td>TTM     </td><td>Transfer Termination     </td><td>NA   </td></tr>
<tr><td>VEM     </td><td>Vertical Editing         </td><td>NA   </td></tr>
</table>
etx

# -- Keyboard Codes -----------------------------------------------------------------

cat >> $RES << etx
<h2>Keyboard Codes</h2>

The notation &lt;ESC&gt; denotes a single ASCII Escape character, 1Bx.

<table border=1>
<tr>
<td>Cursor Key</td>
<td>VT52 mode</td>
<td>ANSI mode w/cursor <br> key mode reset</td>
<td>ANSI mode w/cursor <br> key mode set</td>
</tr>
<tr><td>UP   </td><td>&lt;ESC&gt;A</td><td>&lt;ESC&gt;[A</td><td>&lt;ESC&gt;OA</td></tr>
<tr><td>DOWN </td><td>&lt;ESC&gt;B</td><td>&lt;ESC&gt;[B</td><td>&lt;ESC&gt;OB</td></tr>
<tr><td>RIGHT</td><td>&lt;ESC&gt;C</td><td>&lt;ESC&gt;[C</td><td>&lt;ESC&gt;OC</td></tr>
<tr><td>LEFT </td><td>&lt;ESC&gt;D</td><td>&lt;ESC&gt;[D</td><td>&lt;ESC&gt;OD</td></tr>
</table>
etx


# -- Graphics Characters ------------------------------------------------------------

cat >> $RES << etx
<h2>Special Graphics Characters</h2>

If the Special Graphics set is selected, the graphics for ASCII codes
0137 through 0176 will be replaced according to the following table (see the
<a href=#SCS>SCS</a> control sequence).
etx


awk -f awk.table.graphic < Table.Graphic >> $RES


cat >> $RES << etx
<em>NOTE 1</em>: Codes 0152-0156 and 0164-0170 are used to draw rectangular grids" each
piece of this set is contiguous with other so the lines formed will be
unbroken.
<p>
<em>NOTE 2</em>: Codes 0157-0163 give better vertical resolution than dashes and
underlines when drawing graphs; using these segments, 120 x 132 resolution may
be obtained in 132 column mode with the Advanced Video Option installed.
<p>

<h2>References</h2>
<em>NOTE</em>: ANSI standards may be obtained by writing:
<center>American National Standards Institute</center>
<center>Sales Department</center>
<center>1430 Broadway</center>
<center>New York, NY, 10018</center>
etx


cat >> $RES << etx
<hr>
<h3>Other Material</h3>
<a href="nomailto:">Petri Virekoski</a> has posted much of
this document to <a href="news:comp.terminals">comp.terminals</a>
in 1993.  It is largely derived from DEC document EK-VT100-UG-003,
the original manual for the VT100.
I htmlized and edited his posting in 1998 to provide the
<code>Konsole</code> program with proper reference material.
The original author is mentioned here only to honor his work,
he has nothing to do with <code>Konsole</code>. Do not bother
him with any questions.
<p>
Most so-called VT100 implementations (both stand-alone terminals and
PC emulators) actually implement more controls than are given here. 
The minimal standard is really the slightly more advanced VT102 terminal.
<p>
<hr>
<small>
This text is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
<p>
<a href="mailto:lars.doelle@on-line.de">Lars D&ouml;lle</a>, 1998
</small>

</body>
</html>
etx
