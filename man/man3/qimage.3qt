.TH QImage 3qt "26 Febrary 1999" "Troll Tech AS" \" -*- nroff -*-
.\" Copyright 1992-1997 Troll Tech AS.  All rights reserved.  See the
.\" LICENSE file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QImage \- Hardware-independent pixmap representation with direct access to the pixel data
.SH SYNOPSIS
.br
.PP
\fC#include <qimage.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "QImage ()"
.br
.ti -1c
.BI "QImage ( int " "width" ", int " "height" ", int " "depth" ", int " "numColors" "=0, Endian " "bitOrder" "=IgnoreEndian )"
.br
.ti -1c
.BI "QImage ( const QSize &, int " "depth" ", int " "numColors" "=0, Endian " "bitOrder" "=IgnoreEndian )"
.br
.ti -1c
.BI "QImage ( const char * " "fileName" ", const char * " "format" "=0 )"
.br
.ti -1c
.BI "QImage ( const char * xpm[] )"
.br
.ti -1c
.BI "QImage ( const QImage & )"
.br
.ti -1c
.BI "\fB~QImage\fR ()"
.br
.ti -1c
.BI "QImage& operator= ( const QImage & )"
.br
.ti -1c
.BI "QImage& operator= ( const QPixmap & )"
.br
.ti -1c
.BI "bool operator== ( const QImage & ) const"
.br
.ti -1c
.BI "bool operator!= ( const QImage & ) const"
.br
.ti -1c
.BI "void detach ()"
.br
.ti -1c
.BI "QImage copy () const"
.br
.ti -1c
.BI "QImage copy ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "conversion_flags" "=0 ) const"
.br
.ti -1c
.BI "QImage copy ( QRect & ) const"
.br
.ti -1c
.BI "bool isNull () const"
.br
.ti -1c
.BI "int width () const"
.br
.ti -1c
.BI "int height () const"
.br
.ti -1c
.BI "QSize size () const"
.br
.ti -1c
.BI "QRect rect () const"
.br
.ti -1c
.BI "int depth () const"
.br
.ti -1c
.BI "int numColors () const"
.br
.ti -1c
.BI "Endian bitOrder () const"
.br
.ti -1c
.BI "QRgb color ( int i ) const"
.br
.ti -1c
.BI "void setColor ( int " "i" ", QRgb c )"
.br
.ti -1c
.BI "void setNumColors ( int )"
.br
.ti -1c
.BI "bool hasAlphaBuffer () const"
.br
.ti -1c
.BI "void setAlphaBuffer ( bool )"
.br
.ti -1c
.BI "bool allGray () const"
.br
.ti -1c
.BI "bool isGrayscale () const"
.br
.ti -1c
.BI "uchar* bits () const"
.br
.ti -1c
.BI "uchar* scanLine ( int ) const"
.br
.ti -1c
.BI "uchar** jumpTable () const"
.br
.ti -1c
.BI "QRgb* colorTable () const"
.br
.ti -1c
.BI "int numBytes () const"
.br
.ti -1c
.BI "int bytesPerLine () const"
.br
.ti -1c
.BI "bool create ( int " "width" ", int " "height" ", int " "depth" ", int " "numColors" "=0, Endian " "bitOrder" "=IgnoreEndian )"
.br
.ti -1c
.BI "bool create ( const QSize &, int " "depth" ", int " "numColors" "=0, Endian " "bitOrder" "=IgnoreEndian )"
.br
.ti -1c
.BI "void reset ()"
.br
.ti -1c
.BI "void fill ( uint pixel )"
.br
.ti -1c
.BI "QImage convertDepth ( int ) const"
.br
.ti -1c
.BI "QImage convertDepthWithPalette ( int, QRgb * " "p" ", int " "pc" ", int " "cf" "=0 ) const"
.br
.ti -1c
.BI "QImage convertDepth ( int, int conversion_flags ) const"
.br
.ti -1c
.BI "QImage convertBitOrder ( Endian ) const"
.br
.ti -1c
.BI "QImage smoothScale ( int " "width" ", int height ) const"
.br
.ti -1c
.BI "QImage createAlphaMask ( int conversion_flags ) const"
.br
.ti -1c
.BI "QImage createHeuristicMask ( bool " "clipTight" "=TRUE ) const"
.br
.ti -1c
.BI "bool load ( const char * " "fileName" ", const char * " "format" "=0 )"
.br
.ti -1c
.BI "bool loadFromData ( const uchar * " "buf" ", uint " "len" ", const char * " "format" "=0 )"
.br
.ti -1c
.BI "bool loadFromData ( QByteArray " "data" ", const char * " "format" "=0 )"
.br
.ti -1c
.BI "bool save ( const char * " "fileName" ", const char * format ) const"
.br
.ti -1c
.BI "bool valid ( int " "x" ", int y ) const"
.br
.ti -1c
.BI "int pixelIndex ( int " "x" ", int y ) const"
.br
.ti -1c
.BI "QRgb pixel ( int " "x" ", int y ) const"
.br
.ti -1c
.BI "void setPixel ( int " "x" ", int " "y" ", uint index_or_rgb )"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "Endian systemBitOrder ()"
.br
.ti -1c
.BI "Endian systemByteOrder ()"
.br
.ti -1c
.BI "const char* imageFormat ( const char * fileName )"
.br
.ti -1c
.BI "QStrList inputFormats ()"
.br
.ti -1c
.BI "QStrList outputFormats ()"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
(Note that these are not member functions.)
.in +1c
.ti -1c
.BI "QDataStream & operator<< (QDataStream & " "s" ", const QImage & " "image" ")"
.br
.ti -1c
.BI "QDataStream & operator>> (QDataStream & " "s" ", QImage & " "image" ")"
.br
.in -1c
.SH DESCRIPTION
The QImage class provides a hardware-independent pixmap representation with direct access to the pixel data.
.PP
It is one of the two classes Qt provides for dealing with images, the other being QPixmap. QImage is designed and optimized for I/O and for direct pixel access/manipulation, QPixmap is designed and optimized for drawing. There are (slow) functions to convert between QImage and QPixmp; QPixmap::convertToImage() and QPixmap::convertFromImage().
.PP
An image has the parameters width, height and depth (bits per pixel, bpp), a color table and the actual pixels. QImage supports 1-bpp, 8-bpp and 32-bpp image data. 1-bpp and 8-bpp images use a color lookup table; the pixel value is a color table index.
.PP
32-bpp images encode an RGB value in 24 bits and ignore the color table. The most significant byte is used for the alpha buffer.
.PP
An entry in the color table is an RGB triplet encoded as \fCuint.\fR Use the qRed, qGreen and qBlue functions (qcolor.h) to access the components, and qRgb to make an RGB triplet (see the QColor class documentation).
.PP
1-bpp (monochrome) images have a color table with maximum 2 colors. There are two different formats; big endian (MSB first) or little endian (LSB first) bit order. To access a single bit, you will have to do some bitshifts:
.PP
.nf
.br
    QImage image;
.br
      // sets bit at (x,y) to 1
.br
    if ( image.bitOrder() == QImage::LittleEndian )
.br
        *(image.scanLine(y) + (x >> 3)) |= 1 << (x & 7);
.br
    else
.br
        *(image.scanLine(y) + (x >> 3)) |= 1 << (7 -(x & 7));
.fi
.PP
If this looks complicated, it might be a good idea to convert the 1-bpp image to an 8-bpp image using convertDepth().
.PP
8-bpp images are much easier to work with than 1-bpp images because they have a single byte per pixel:
.PP
.nf
.br
    QImage image;
.br
      // set entry 19 in the color table to yellow
.br
    image.setColor( 19, qRgb(255,255,0) );
.br
      // set 8 bit pixel at (x,y) to value yellow (in color table)
.br
    *(image.scanLine(y) + x) = 19;
.fi
.PP
32-bpp images ignore the color table, instead each pixel contains the RGB triplet. 24 bits contain the RGB value and the most significant byte is reserved for the alpha buffer.
.PP
.nf
.br
    QImage image;
.br
      // sets 32 bit pixel at (x,y) to yellow.
.br
    uint *p = (uint *)image.scanLine(y) + x;
.br
    *p = qRgb(255,255,0);
.fi
.PP
The scanlines are 32-bit aligned for all depths.
.PP
The QImage class uses explicit sharing, similar to that of QArray and QString.
.PP
See also: QImageIO, QPixmap and Shared Classes
.PP
Examples:
.(l
qtimage/qtimage.cpp desktop/desktop.cpp qmag/qmag.cpp
.)l
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QImage::QImage ()"
Constructs a null image.
.PP
See also: isNull().
.SH "QImage::QImage ( const QImage & image )"
Constructs a shallow copy of \fIimage.\fR
.SH "QImage::QImage ( const char * fileName, const char * format=0 )"
Constructs an image from loading \fIfileName\fR and an optional \fIformat.\fR
.PP
See also: load().
.SH "QImage::QImage ( const char * xpm[] )"
Constructs an image from \fIxpm,\fR which must be a valid XPM image.
.PP
Errors are silently ignored.
.SH "QImage::QImage ( int w, int h, int depth, int numColors=0, Endian bitOrder=IgnoreEndian )"
Constructs an image with \fIw\fR width, \fIh\fR height, \fIdepth\fR bits per pixel, \fInumColors\fR colors and bit order \fIbitOrder.\fR
.PP
Using this constructor is the same as first constructing a null image and then calling the create() function.
.PP
See also: create().
.SH "QImage::QImage ( const QSize &, int depth, int numColors=0, Endian bitOrder=IgnoreEndian )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "QImage::~QImage ()"
Destroys the image and cleans up.
.SH "bool QImage::allGray () const"
Returns TRUE if all the colors in the image are shades of gray, that is their R, G, and B components are equal. This function is slow for large 32-bit images.
.SH "QImage::Endian QImage::bitOrder() const"
Returns the bit order for the image.
.PP
If it is a 1-bpp image, this function returns either QImage::BigEndian or QImage::LittleEndian.
.PP
If it is not a 1-bpp image, this function returns QImage::IgnoreEndian.
.PP
See also: depth().
.SH "uchar * QImage::bits () const"
Returns a pointer to the first pixel data. Equivalent to scanLine(0).
.PP
See also: scanLine().
.SH "int QImage::bytesPerLine () const"
Returns the number of bytes per image scanline. This is equivalent to numBytes()/height().
.SH "QRgb QImage::color ( int i ) const"
Returns the color in the color table at index \fIi.\fR
.PP
A color value is an RGB triplet. Use the QRED, QGREEN and QBLUE functions (defined in qcolor.h) to get the color value components.
.PP
See also: setColor() and QColor.
.SH "QRgb * QImage::colorTable () const"
Returns a pointer to the color table.
.SH "QImage QImage::convertBitOrder ( Endian bitOrder ) const"
Converts the bit order of the image to \fIbitOrder\fR and returns the converted image.
.PP
Returns \fC*this\fR if the \fIbitOrder\fR is equal to the image bit order, or a null image if this image cannot be converted.
.PP
See also: bitOrder() and setBitOrder().
.SH "QImage QImage::convertDepth ( int depth, int conversion_flags ) const"
Converts the depth (bpp) of the image to \fIdepth\fR and returns the converted image. The original image is left undisturbed.
.PP
The \fIdepth\fR argument must be 1, 8 or 32.
.PP
See QPixmap::convertFromImage for a description of the \fIconversion_flags\fR argument.
.PP
Returns \fC*this\fR if \fIdepth\fR is equal to the image depth, or a null image if this image cannot be converted.
.PP
See also: depth() and isNull().
.SH "QImage QImage::convertDepth ( int depth ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "QImage QImage::convertDepthWithPalette ( int d, QRgb * palette, int palette_count, int conversion_flags=0 ) const"
Note: currently no closest-color search is made. If colors are found that are not in the palette, the palette may not be used at all. This result should not be considered valid, as it may change in future implementations.
.PP
Currently inefficient for non 32-bit images.
.SH "QImage QImage::copy () const"
Returns a deep copy of the image.
.SH "QImage QImage::copy ( int x, int y, int w, int h, int conversion_flags=0 ) const"
Returns a deep copy of a sub-area of the image.
.PP
See also: bitBlt().
.SH "QImage QImage::copy ( QRect & r ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "bool QImage::create ( int width, int height, int depth, int numColors=0, Endian bitOrder=IgnoreEndian )"
Sets the image width, height, depth, number of colors and bit order. Returns TRUE if successful, or FALSE if the parameters are incorrect or if memory cannot be allocated.
.PP
The \fIwidth\fR and \fIheight\fR is limited to 32767. \fIdepth\fR must be 1, 8 or 32. If \fIdepth\fR is 1, then \fIbitOrder\fR must be set to either QImage::LittleEndian or QImage::BigEndian. For other depths, \fIbitOrder\fR must be QImage::IgnoreEndian.
.PP
This function allocates a color table and a buffer for the image data. The image data is not initialized.
.PP
The image buffer is allocated as a single block that consists of a table of scanline pointers (jumpTable()) and the image data (bits()).
.PP
See also: width(), height(), depth(), numColors(), bitOrder(), jumpTable(), scanLine(), bits(), bytesPerLine() and numBytes().
.SH "bool QImage::create ( const QSize &, int depth, int numColors=0, Endian bitOrder=IgnoreEndian )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "QImage QImage::createAlphaMask ( int conversion_flags ) const"
Builds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if alpha buffer mode is disabled.
.PP
See QPixmap::convertFromImage for a description of the \fIconversion_flags\fR argument.
.PP
The returned image has little-endian bit order, which you can convert to big-endianness using convertBitOrder().
.SH "QImage QImage::createHeuristicMask ( bool clipTight=TRUE ) const"
Creates and returns a 1-bpp heuristic mask for this image. It works by selecting a color from one of the corners, then chipping away pixels of that color, starting at all the edges.
.PP
The four corners vote over which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image) the voting results are undocumented.
.PP
The returned image has little-endian bit order, which you can convert to big-endianness using convertBitOrder().
.PP
This function disregards the alpha buffer.
.SH "int QImage::depth () const"
Returns the depth of the image.
.PP
The image depth is the number of bits used to encode a single pixel, also called bits per pixel (bpp) or bit planes of an image.
.PP
The supported depths are 1, 8 and 32.
.SH "void QImage::detach ()"
Detaches from shared image data and makes sure that this image is the only one referring the data.
.PP
If multiple images share common data, this image makes a copy of the data and detaches itself from the sharing mechanism. Nothing is done if there is just a single reference.
.SH "void QImage::fill ( uint pixel )"
Fills the entire image with the pixel value \fIpixel.\fR
.PP
If the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2) etc., the image is filled with 0s. If you say fill(1), fill(3) etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used.
.PP
If the depth is 32 and the image has no alpha buffer, the \fIpixel\fR value is written to each pixel in the image. If the image has an alpha buffer, only the 24 RGB bits are set and the upper 8 bits (alpha value) are left unchanged.
.SH "bool QImage::hasAlphaBuffer () const"
Returns TRUE if alpha buffer mode is enabled, otherwise FALSE.
.PP
See also: setAlphaBuffer().
.SH "int QImage::height () const"
Returns the height of the image.
.PP
See also: width(), size() and rect().
.SH "const char * QImage::imageFormat ( const char * fileName ) \fC[static]\fR"
Returns a string that specifies the image format of the file \fIfileName,\fR or null if the file cannot be read or if the format cannot be recognized.
.PP
The QImageIO documentation lists the guaranteed supported image formats, or use the QImage::inputFormats() QImage::outputFormats() to get lists that include installed formats.
.PP
See also: load() and save().
.SH "QStrList QImage::inputFormats () \fC[static]\fR"
Returns a list of image formats which are supported for image input.
.SH "bool QImage::isGrayscale () const"
Returns TRUE if the image is allGray(), \fIand\fR if the image is 32-bpp or a 256-color 8-bpp image for which color(i) is QRgb(i,i,i).
.SH "bool QImage::isNull () const"
Returns TRUE if it is a null image.
.PP
A null image has all parameters set to zero and no allocated data.
.PP
Examples:
.(l
qtimage/qtimage.cpp
.)l
.SH "uchar ** QImage::jumpTable () const"
Returns a pointer to the scanline pointer table.
.PP
This is the beginning of the data block for the image.
.SH "bool QImage::load ( const char * fileName, const char * format=0 )"
Loads an image from the file \fIfileName.\fR Returns TRUE if successful, or FALSE if the image could not be loaded.
.PP
If \fIformat\fR is specified, the loader attempts to read the image using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file format.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also: loadFromData(), save(), imageFormat(), QPixmap::load() and QImageIO.
.SH "bool QImage::loadFromData ( const uchar * buf, uint len, const char * format=0 )"
Loads an image from the binary data in \fIbuf\fR (\fIlen\fR bytes). Returns TRUE if successful, or FALSE if the image could not be loaded.
.PP
If \fIformat\fR is specified, the loader attempts to read the image using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file format.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also: load(), save(), imageFormat(), QPixmap::loadFromData() and QImageIO.
.SH "bool QImage::loadFromData ( QByteArray buf, const char * format=0 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "int QImage::numBytes () const"
Returns the number of bytes occupied by the image data.
.PP
See also: bytesPerLine().
.SH "int QImage::numColors () const"
Returns the size of the color table for the image.
.PP
Notice that numColors() returns 0 for 32-bpp images, since these images do not use color tables, but instead encode pixel values as RGB triplets.
.SH "bool QImage::operator!= ( const QImage & i ) const"
Returns TRUE if this image and \fIi\fR have different contents, and FALSE if they they have the same. This can be slow. Of course, this function returns quickly if e.g. the two images' widths are different.
.PP
See also: operator=().
.SH "QImage & QImage::operator= ( const QPixmap & pixmap )"
Sets the image bits to the \fIpixmap\fR contents and returns a reference to the image.
.PP
If the image shares data with other images, it will first dereference the shared data.
.PP
Makes a call to QPixmap::convertToImage().
.SH "QImage & QImage::operator= ( const QImage & image )"
Assigns a shallow copy of \fIimage\fR to this image and returns a reference to this image.
.PP
See also: copy().
.SH "bool QImage::operator== ( const QImage & i ) const"
Returns TRUE if this image and \fIi\fR have the same contents, and FALSE if they differ. This can be slow. Of course, this function returns quickly if e.g. the two images' widths are different.
.PP
See also: operator=().
.SH "QStrList QImage::outputFormats () \fC[static]\fR"
Returns a list of image formats which are supported for image output.
.SH "QRgb QImage::pixel ( int x, int y ) const"
Returns the actual color of the pixel at the given coordinates.
.PP
If (x,y) is not on the image, the results are undefined.
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "int QImage::pixelIndex ( int x, int y ) const"
Returns the pixel index at the given coordinates.
.PP
If (x,y) is not valid, or if the image is not a paletted image (depth() > 8), the results are undefined.
.SH "QRect QImage::rect () const"
Returns the enclosing rectangle (0,0,width(),height()) of the image.
.PP
See also: width(), height() and size().
.SH "void QImage::reset ()"
Resets all image parameters and deallocates the image data.
.PP
Examples:
.(l
qtimage/qtimage.cpp
.)l
.SH "bool QImage::save ( const char * fileName, const char * format ) const"
Saves the image to the file \fIfileName,\fR using the image file format \fIformat.\fR Returns TRUE if successful, or FALSE if the image could not be saved.
.PP
See also: load(), loadFromData(), imageFormat(), QPixmap::save() and QImageIO.
.SH "uchar * QImage::scanLine ( int i ) const"
Returns a pointer to the pixel data at the \fIi'th\fR scanline.
.PP
The scanline data is aligned on a 32-bit boundary.
.PP
\fBWarning:\fR If you are accessing 32-bpp image data, cast the returned pointer to \fCQRgb*\fR (QRgb has a 32 bit size) and use it to read/write the pixel value. You cannot use the \fCuchar*\fR pointer directly, because the pixel format depends on the byte order on the underlying platform. Hint: use qRed() and friends (qcolor.h) to access the pixels.
.PP
See also: bits().
.PP
Examples:
.(l
desktop/desktop.cpp
.)l
.SH "void QImage::setAlphaBuffer ( bool enable )"
Enables alpha buffer mode if \fIenable\fR is TRUE, otherwise disables it. The default setting is disabled.
.PP
An 8-bpp image has 8 bit pixels. A pixel is an index into the color table, which contains 32-bit color values. In a 32-bpp image, the 32 bit pixels are the color values.
.PP
This 32 bit value is encoded as follows: The lower 24 bits are used for the red, green and blue components. The upper 8 bits contain the alpha component.
.PP
The alpha component specifies the transparency of a pixel. 0 means completely transparent and 255 means opaque. The alpha component is ignored if you do not enable alpha buffer mode.
.PP
The alpha buffer is used to set a mask when a QImage is translated to a QPixmap.
.PP
See also: hasAlphaBuffer() and createAlphaMask().
.SH "void QImage::setColor ( int i, QRgb c )"
Sets a color in the color table at index \fIi\fR to \fIc.\fR
.PP
A color value is an RGB triplet. Use the qRgb function (defined in qcolor.h) to make RGB triplets.
.PP
See also: color().
.PP
Examples:
.(l
desktop/desktop.cpp
.)l
.SH "void QImage::setNumColors ( int numColors )"
Resizes the color table to \fInumColors\fR colors.
.PP
If the color table is expanded, then all new colors will be set to black (RGB 0,0,0).
.PP
See also: color() and setColor().
.SH "void QImage::setPixel ( int x, int y, uint index_or_rgb )"
Sets the pixel index or color at the given coordinates.
.PP
If (x,y) is not valid, or if the image is a paletted image (depth() <= 8) and \fIindex_or_rgb\fR >= numColors(), the results are undefined.
.SH "QSize QImage::size () const"
Returns the size of the image.
.PP
See also: width(), height() and rect().
.SH "QImage QImage::smoothScale ( int width, int height ) const"
Returns a copy of the image smoothly scaled to \fIwidth\fR by \fIheight\fR pixels. For 32-bpp images, and 1-bpp/8-bpp color images, the result will be 32-bpp, while all-gray images (including black-and-white 1-bpp) will produce 8-bit grayscale images with the palette spanning 256 grays from black to white.
.PP
This function uses code based on:
.PP
pnmscale.c - read a portable anymap and scale it
.PP
Copyright (C) 1989, 1991 by Jef Poskanzer.
.PP
Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. This software is provided "as is" without express or implied warranty.
.SH "QImage::Endian QImage::systemBitOrder() \fC[static]\fR"
Determines the bit order of the display hardware. Returns QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
.SH "QImage::Endian QImage::systemByteOrder() \fC[static]\fR"
Determines the host computer byte order. Returns QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
.SH "bool QImage::valid ( int x, int y ) const"
Tests if the ( \fIx, y\fR ) is a valid coordinate in the image.
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "int QImage::width () const"
Returns the width of the image.
.PP
See also: heigth(), size() and rect().
.SH RELATED FUNCTION DOCUMENTATION
.SH "QDataStream & operator<< (QDataStream & s, const QImage & image)"
Writes an image to the stream as a BMP image.
.PP
See also: QImage::save().
.SH "QDataStream & operator>> (QDataStream & s, QImage & image)"
Reads an image from the stream.
.PP
See also:  QImage::load().
.SH "SEE ALSO"
.BR http://www.troll.no/qt/qimage.html
.SH COPYRIGHT
Copyright 1992-1997 Troll Tech AS.  See the LICENSE file included in
the distribution for a complete license statement.
.SH AUTHOR
Generated automatically from the source code.
